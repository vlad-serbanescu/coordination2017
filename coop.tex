\section{Cooperative Scheduling Implementation Schemes}

-sequence diagram of what happens in an actor during synchronous and asynchronous method calls.

\subsection{Modeling Language Concepts in the JVM}
\paragraph{An Actor has a lock and Every Asynchronous call is a Thread}
The trivial straightforward approach for implementing cooperative scheduling in Java is to model each actor as an object with a lock for which execution threads compete. Each asynchronous call would then generate a new thread with it own stack and context. Whenever a control switch statement occurs the thread would be suspended by the JVM's normal behaviour and the available threads would then compete for the actor's lock. When the release condition is enabled the suspended thread would become available and in turn compete with the other available threads in order to execute on the actor. \\
We have one lock per Actor for ensuring single thread execution.

\paragraph{Every Actor is a Thread Pool}
-free queue, less space
-Each async. call is modeled as task.

\paragraph{Every System has a Thread Pool}
-each actor is modeled as a task with a queue of lambda expressions.
-particular uses of an executor service.

\paragraph{Synchronous calls context}
-to save execution context we save the current call stack as a Thread and optimally suspend it

\paragraph{Continuations as tasks}
- fully asynchronous environment\\
- modeling continuations as labeled functions and converting them to lambda expressions.\\
- allocating more memory in the heap and saving memory on the stack.\\

\subsection{Optimizations for the JVM}

\paragraph{Demand-driven Approach}

\paragraph{Optimal Usage of System Threads}

\paragraph{Eliminating Busy Waiting}

\paragraph{Using JVM Garbage Collection}
