%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{listings,calc}
%\usepackage{subcaption}
%\captionsetup{compatibility=false}

\lstset{language=Java, numbers=left, mathescape, columns=fullflexible, keepspaces=true, basicstyle=\lst@ifdisplaystyle\scriptsize\fi}

\usepackage{url}

\urldef{\mailsa}\path|{vlad.serbanescu, frank.s.de.boer, jaghouri}@cwi.nl|  

\newcommand{\keywords}[1]{\par\addvspace\baselineskip
	\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}
	
	\mainmatter  % start of an individual contribution
	
	% first the title is needed
	\title{A Java Run-Time System for Cooperative Scheduling in ABS}
	
	% a short form should be given in case it is too long for the running head
	\titlerunning{Cooperative Scheduling}
	
	% the name(s) of the author(s) follow(s) next
	%
	% NB: Chinese authors should write their first names(s) in front of
	% their surnames. This ensures that the names appear correctly in
	% the running heads and the author index.
	%
	\author{Vlad Serbanescu
		\and Frank de Boer \and Mahdi Jaghouri}
	%
	\authorrunning{Serbanescu et al.}
	% (feature abused for this document to repeat the title also on left hand pages)
	
	% the affiliations are given next; don't give your e-mail address
	% unless you accept that it will be published
	\institute{Leiden Institute of Advanced Computer Science\\
		Centrum Wiskunde and Informatica\\
		\mailsa\\
		\url{http://www.cwi.nl}}
	
	%
	% NB: a more complex sample for affiliations and the mapping to the
	% corresponding authors can be found in the file "llncs.dem"
	% (search for the string "\mainmatter" where a contribution starts).
	% "llncs.dem" accompanies the document class "llncs.cls".
	%
	
	\toctitle{Lecture Notes in Computer Science}
	\tocauthor{Authors' Instructions}
	\maketitle
	
	
	\begin{abstract}
		%Modeling applications at the design phase of any project is highly important in order to build a reliable, fast and robust system. Understanding the control flow of execution from just the model is crucial for the applications next software engineering phases such as implementation, testing, release and maintenance.  If we add that a large portion software systems are running several jobs in parallel, with a good model we can observe data consistency and detect deadlocks efficiently. One of the toughest models to execute, especially in a parallel or distributed environment is the Actor-based model which introduces the notion of cooperative scheduling, a high-level synchronization mechanism which allows an actor to continue to execute messages from its queue when the current message execution is suspended . In this paper we will investigate some of the challenges of translating the cooperative scheduling behavior into the Java Runtime Environment. We will analyze the Abstract Behavioral Specification (ABS) Language concepts which are very well suited for Agent-based applications modeling and provide a benchmark for testing several solutions of efficiently running cooperative scheduling behavior. 
		Actor-based models of computation in general assume a run-to-completion mode
		of execution of the messages.
		The Abstract Behavioral Specification (ABS) Language extends the Actor-based model
		with  a high-level synchronization mechanism which allows actors to suspend the
		execution of the current message and schedule in a cooperative manner another
		queued message.  This  extension  is a powerful means for the expression and analysis
		of fine-grained run-time dependencies between messages.
		
		In this paper we introduce  and evaluate a new run-time system in Java for  the use of ABS as a full-fledged programming language.
		The main challenge is the development of an efficient and scalable implementation of cooperative scheduling.
		By means of a typical benchmark we evaluate our proposed solution and compare it
		to other thread-based implementations of cooperative scheduling.
		
		
		
		
		
		
		
		\keywords{Actors, Cooperative Scheduling, Object-Orientation, Run-Time}
	\end{abstract}
	
	
	\input{intro.tex}
	\input{lang.tex}
	\input{coop.tex}
	\input{compile.tex}
	\input{runtime.tex}
	\input{benchmark.tex}
	\input{conclusion.tex}
	
	
	
	
	
	\begin{thebibliography}{4}

\bibitem{Akka}  Munish K. Gupta:  Akka Essentials. Packt Publishing. p. 334. ISBN 1849518289, 2012.


\bibitem{Scala} Philipp Haller, Martin Odersky:
Scala Actors: Unifying thread-based and event-based programming. Theor. Comput. Sci. 410(2-3): 202-220 (2009)

\bibitem{Sirjani} Marjan  Sirjani, Ali Movaghar:
An actor-based model for formal modelling of reactive systems: Rebeca.
Technical Report. 2001.

  \bibitem{Agha}  Gul Agha: Actors: A model of concurrent computation in distributed systems. Massachusetts Institute of Technology Cambridge Artificial Intelligence Lab.
1985.

\bibitem{Schafer} Jan Sch\"{a}fer:  A Programming Model and Language for Concurrent and Distributed Object-Oriented Systems. 
Dissertation. University of Kaiserslautern, 2010. 

\bibitem{KeY}Din, C. C., Bubel, R., and Hähnle, R. (2015, August). KeY-ABS: a deductive verification tool for the concurrent modelling language ABS. In International Conference on Automated Deduction (pp. 517-526). Springer International Publishing.

\bibitem{Erlang}
Georg G\"{o}ri, Einar Broch Johnsen, Rudolf Schlatte, Volker Stolz:
Erlang-Style Error Recovery for Concurrent Objects with Cooperative Scheduling. ISoLA (2) 2014: 5-21.

\bibitem{Haskell} 	Elvira Albert, Nikolaos Bezirgiannis, Frank S. de Boer, Enrique Martin-Martin:
A Formal, Resource Consumption-Preserving Translation of Actors to Haskell. 
Proceedings LOPSTR 2016.

\bibitem{Encore}
Stephan Brandauer, Elias Castegren, Dave Clarke, Kiko Fernandez-Reyes, Einar Broch Johnsen, Ka I Pun, Silvia Lizeth Tapia Tarifa, Tobias Wrigstad, Albert Mingkun Yang:
Parallel Objects for Multicores: A Glimpse at the Parallel Language Encore. SFM 2015: 1-56

\bibitem{Albert}
	Elvira Albert, Frank S. de Boer, Reiner Hähnle, Einar Broch Johnsen, Rudolf Schlatte, Silvia Lizeth Tapia Tarifa, Peter Y. H. Wong:
Formal modeling and analysis of resource management for cloud architectures: an industrial case study using Real-Time ABS. Service Oriented Computing and Applications 8(4): 323-339 (2014).

\bibitem{deadlock}
Elena Giachino, Cosimo Laneve, Michael Lienhardt:
A framework for deadlock detection in core ABS. Software and System Modeling 15(4): 1013-1048 (2016)


		\bibitem{rabs}Joakim Bjork, Frank S. de Boer, Einar Broch Johnsen, Rudolf Schlatte, Silvia Lizeth Tapia Tarifa:
		User-defined schedulers for real-time concurrent objects. ISSE 9(1): 29-43 (2013)
		
		\bibitem{cgf}De Boer, Frank S., Dave Clarke, and Einar Broch Johnsen. "A complete guide to the future." European Symposium on Programming. Springer Berlin Heidelberg, 2007.
		
		\bibitem{paj8} Nobakht, Behrooz, and Frank S. de Boer. "Programming with actors in Java 8." International Symposium On Leveraging Applications of Formal Methods, Verification and Validation. Springer Berlin Heidelberg, 2014.
		
		\bibitem{bas16} Mehdi Dastani, Bas Testerink:
		Design patterns for multi-agent programming. IJAOSE 5(2/3): 167-202 (2016)
		
		\bibitem{abs} Johnsen, E. B., Hähnle, R., Schäfer, J., Schlatte, R., and Steffen, M. (2010, November). ABS: A core language for abstract behavioral specification. In International Symposium on Formal Methods for Components and Objects (pp. 142-164). Springer Berlin Heidelberg.
		
		\bibitem{cog} Nobakht, B., de Boer, F. S., Jaghoori, M. M., and Schlatte, R. (2012, March). Programming and deployment of active objects with application-level scheduling. In Proceedings of the 27th Annual ACM Symposium on Applied Computing (pp. 1883-1888). ACM.
		
		\bibitem{saco} Albert, E., Arenas, P., Flores-Montoya, A., Genaim, S., Gómez-Zamalloa, M., Martin-Martin, E., and Román-Díez, G. (2014, April). SACO: static analyzer for concurrent objects. In International Conference on Tools and Algorithms for the Construction and Analysis of Systems (pp. 562-567). Springer Berlin Heidelberg.
		
		\bibitem{dead}Flores-Montoya, A. E., Albert, E., and Genaim, S. (2013). May-happen-in-parallel based deadlock analysis for concurrent objects. In Formal Techniques for Distributed Systems (pp. 273-288). Springer Berlin Heidelberg.
		
		\bibitem{dis}Serbanescu, V., Azadbakht, K., and de Boer, F. (2016). A java-based distributed approach for generating large-scale social network graphs. In Resource Management for Big Data Platforms (pp. 401-417). Springer International Publishing.
		
		\bibitem{cloud} Bezirgiannis, N., and de Boer, F. (2016, January). ABS: a high-level modeling language for cloud-aware programming. In International Conference on Current Trends in Theory and Practice of Informatics (pp. 433-444). Springer Berlin Heidelberg.
		
		\bibitem{agent_auction}Franco Zambonelli, Nicholas R. Jennings, Michael Wooldridge. 
		Organisational Abstractions for the Analysis and Design of Multi-agent Systems
		Agent-Oriented Software Engineering. Volume 1957 of the series Lecture Notes in Computer Science pp 235-251
		
		\bibitem{creol} Johnsen, E. B., Owe, O., and Yu, I. C. (2006). Creol: A type-safe object-oriented model for distributed concurrent systems. Theoretical Computer Science, 365(1-2), 23-66.
		
		\bibitem{resume} Johnsen, E. B., Owe, O., and Axelsen, E. W. (2005). A run-time environment for concurrent objects with asynchronous method calls. Electronic Notes in Theoretical Computer Science, 117, 375-392.
		
		\bibitem{execserv} https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html
		
		\bibitem{railway}Hahnle, R., and Muschevici, R. (2016, October). Towards incremental validation of railway systems. In International Symposium on Leveraging Applications of Formal Methods (pp. 433-446). Springer International Publishing.
		
		\bibitem{library}https://github.com/vlad-serbanescu/abs-api-cwi.git
		\bibitem{lambdas} https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html
	\end{thebibliography}
	
\appendix
\section{Appendices} 
\subsection{ An Auctioning system in ABS}
\label{a1}
\begin{lstlisting}
module AuctionDemo;

type Price = Rat;
type Belief = Price; // Budget for biddingagent = its belief base
type BeliefBase = Map<Route, Price>; // bb for auctioneeragent
type GoalBase = Set<Goal>;

data Route = ARoute(Rat departure, Maybe<Destination> city);
data Goal = AGoal(Rat availableSince, Rat deadline, Maybe<Destination> dest);
data Message = 
	Announce(Agent announceCaller, Route toSell, Price price) | 
	Bid(Agent bidCaller, Route toBuy, Price bid) |
	Sold(Agent soldCaller, Route soldItem) |
	Result(Set<Agent> winners, List<Price> prices, List<Agent> unhappy);

interface Destination {
	String getName();
	Rat getDrivingTimeFromRtm();
	Rat getCostToDriveToDestination();
}

interface BiddingInfo{
	String getId();
	Goal getGoal();
	Price getBudget();
	Rat getArrivalTime();
	Rat getDeadline();
	Unit setPaidPrice(Price price);
	Price getPaidPrice();
	AuctioneerInfo asAuctioneer();   
	// a bidding agent can become an auctioneer (for trains) -- container returns null
}

interface AuctioneerInfo{
	Int getNumberOfWinners();
}

// a number that says how much the bidder is interested: if the bidder has time then it bids less
// RESULT RANGE: (0,1] , 1 most interested    
def Rat strictFit(Goal g, Route r) = 
case g {
	AGoal(arrival, deadline, goalDest) => case r {
		ARoute(time, dest) =>
			if (time > deadline) then
				-1
			else if ((dest == goalDest || ( (isJust(dest))) 
			||( (isJust(goalDest)))) && (arrival <= time)) then
				(time - arrival + 1) / (deadline - arrival + 1)   
				// deadline missed == no point in going anymore
			else
				0;
};	};

// risk and timeFit must be between 0..1 so that bid stays between min and budget
// risk is a parameter of every bidderagent given by DSOL
def Price bidStrategy(Price min, Price budget, Rat timeFit, Rat risk) =
	if (budget < min) then
		0
	else if (timeFit <= 0) then
		timeFit   // means either not interested or unhappy
	else
		min + (budget - min) * timeFit * risk;

interface Agent {
	Unit message(Message m);
}

interface AuctionOrganizer {
	// create trains and containers agents
	Unit init(List<BiddingInfo> trains, List<BiddingInfo> containers);
	// organize two auctions 
	Unit start(Rat timeSlot, DSOL caller);
}

class AuctionOrganizerAgent implements AuctionOrganizer {
	Unit init(List<BiddingInfo> trains, List<BiddingInfo> containers){
		//Agent t = new BiddingAgent(APair(Route(900, Nothing), 10));
	}
	Unit start(Rat timeSlot, DSOL caller){
		// new AuctioneerAgent (for the 1 train)
		
		// await for the auction results
		
		// new AuctioneerAgent (for the containers)
		
		// await
		
		// send it to DSOL through done
}	}

interface DSOL {
	Unit done(Rat timeSlot, Destination dest, AuctioneerInfo tr, List<BiddingInfo> winnerContainers, 
		List<BiddingInfo> unhappyTrains, List<BiddingInfo> unhappyContainers);
}

// init_value and init_gaol must be about the same route, 

// each biddingagent has to have a comparable unique identifier for reproducibility
class BiddingAgent(Belief init_value, Goal init_goal, Rat risk) implements Agent {
	Belief belief = init_value;
	Set<Goal> goals = set[init_goal];
	
	Unit message(Message m) {
		case m {
			Announce(caller, slot, price) =>  {
				println("Received announce");
				Price budget = belief;
				if (goals != EmptySet) {
					Goal goal = take(goals);  
					 // we have only one goal, we assume for now it's only 1 and same
					Rat timeFit = strictFit(goal, slot);
					Price myOffer = bidStrategy(price, budget, timeFit, risk);
					println("Sending a bid: "+intToString(myOffer));
					if (myOffer < 0) {
						goals = EmptySet;   // unhappy
					} else{ if (myOffer > 0) {   // zero bid == not interested
						Fut<Unit> f = caller ! message(Bid(this, slot, myOffer));
						await f?;  // alternative: return the bid value
					}}
				}
			}
			Sold(caller, slot) => {
				println("I won the auction for: slot "); 
				goals = EmptySet;
			}
			_ => { println("Unexpected message."); }
}	}	}

class AuctioneerAgent(BeliefBase itemValues, Set<Route> init_goals, Set<Agent> bidderList, 
						Int numWinners, Agent organizer) implements Agent {
	BeliefBase beliefs = itemValues;	// what I think items are worth
	Set<Route> goals = init_goals;
	
	Map<Route, Pair<Agent, Price>> winners = map[];
	
	Unit message(Message m) {
		case m { 
			Bid(caller, slot, price) =>  {
				println("Received a bid.");
				Maybe<Pair<Agent, Price>> mValue = lookup(winners, slot);
				case mValue {
					Just(APair(topAgent, topPrice)) => {
						// keep track of unhappy agents (returned -1) in a list 
						//and return it to AuctonOrganizer.done()
						// keep a list of winners and their bids
						// (+ 1 spot) because there are multiple winners
						if (price > topPrice) {	// if equal we favor the first bid 
							winners = put(winners, slot, APair(caller, price));	
							// replace with the new top bid
						}
					}
					Nothing => {
						Price min = case lookup(beliefs, slot) {
							Just(value) =>  value;
							Nothing =>  0; 	// if no value is known, we sell it for any price 
						};
						if (price >= min) {winners = put(winners, slot, APair(caller, price));} 
						// first bid
					}	}	}
			_ => { println("Unexpected message."); }
	}	}
	
	Unit goal_rule(Route g) {
		println("Starting an auction.");
		Maybe<Price> maybe = lookup(beliefs, g);
		Price p = case maybe {
			Just(value) =>  value;
			Nothing =>  0; 	// if no value is known, we sell it for any price
		};
		println(" inform all bidders");
		Set<Agent> iBidder = bidderList;
		List<Fut<Unit>> toBid = Nil;
		while (hasNext(iBidder)) {
			Pair<Set<Agent>,Agent> nA = next(iBidder);
			case nA {
				APair(rest, b) => {
					println("Announcing item: ");
					iBidder = rest;
					Fut<Unit> f = b ! message(Announce(this, g, p));
					toBid = Cons(f, toBid);
				}
				_ => {println("next is not there?");}
		}	}
		println("All informed. Now waiting");
		// can I await for all futures in one go?
		while (toBid != Nil) {
			println("going to await");
			case toBid {
				Cons(f, fs) => {
					//await f?;
					toBid = fs;
		}	}	}
		// Bids are sent, but maybe not yet processed?
		println("Now all bids are received ");
		// match from winners list winner(i) with bid(winner(i+1))
		
		Maybe<Pair<Agent, Price>> mValue = lookup(winners, g);
		case mValue {
				Just(APair(winningAgent, price)) => {
					if (winningAgent == null) {
						println("No winner!");
						// should we reduce the expected price?
					} else {
					println("Sold for the price of: "+ intToString(price));
					winningAgent ! message(Sold(this, g));
					goals = remove(goals, g); // will add again if not sold?
					// inform organizer (list of winners and list of unhappy)
			}	}
			Nothing => { println("Error"); 
			}
	}	}

	Unit run() {
		println("Auctioneer started.");
		while(this.goals != EmptySet) {
			// in Haskell: mapM(goal_rule, this.goals);
			// in plain ABS
			Set<Route> iGoals = this.goals;
			List<Fut<Unit>> goalFutures = Nil;
			while (hasNext(iGoals)) {
				Pair<Set<Route>,Route> nA = next(iGoals);
				case nA {
					APair(rest, g) => {
						iGoals = rest;
						Fut<Unit> f = this ! goal_rule(g);
						goalFutures = Cons(f,goalFutures);
					}
				}
			}
			println("Auctioneer finished the goals!");
			while (goalFutures != Nil) {
				case goalFutures {
					Cons(f, fs) => {
						//await f?;
						goalFutures = fs;
}	}	}	}	}	}
\end{lstlisting}	
\end{document}
