

\section{ABS Language Concepts}
\label{lang}
Our reference modeling language for analyzing cooperative scheduling is ABS \cite{abs}, an actor-based modeling language whose semantics offers high-level synchronization mechanisms for parallel and  distributed applications. This is a very powerful modeling language with extensive support for concurrent programming \cite{cog}, resource analysis \cite{saco}, deadlock analysis \cite{dead} and remote communication \cite{dis,cloud}. Our focus in this paper are  high-level constructs for modeling asynchronous communication between actors using messages and cooperative scheduling of these messages by an actor.
%Mahdi:
{\bfseries the following are not the `focus of this paper' as suggested in the previous sentence}
The second construct can have optional annotations that define custom schedulers in order to satisfy an actor's specific behavior. Asynchronous method calls can also be annotated with costs and deadlines which can be combined with cooperative scheduling policies to create a very powerful scheduler.

\subsection{Asynchronous Method Invocation}\label{amc}
In ABS all actors communicate with each other using asynchronous method invocation.
This is written as ``a!m()" which sends a message to another actor ``a" to execute method ``m". 
The semantics additionally allows for synchronous method calls that only change the internal state of an actor $\leftarrow$ {\bfseries what does this mean?}. 
%ABS also has support for grouping Actors into Concurrent Object Groups (COG) that allow synchronous communication between actors of the same COG, but for the scope of our analysis and implementation simplicity we will assume that each actor is defined in its own group.  <-- then I would drop it from here
Each ABS actor has a queue that stores all invocations coming from other actors as messages that are to be executed. 
Each actor executes the messages sequentially in its own context while all actors run in parallel.  
The result of an asynchronous method invocation can be captured in an future which the caller actor can use to retrieve the result, but also to block its current execution in order to synchronize with the callee actor. 
This is done through the ``future.get" statement that a future supplies. % and has the same semantics as futures in other modeling and programming languages.  
One may also send the future as parameter to a message, allowing other actors to use the results.

An important observation to make here is that in modeling an application, ABS assumes there is no ``message overtaking", that is the order of messages delivered from one particular actor to another is the same as the order in which they were generated. 
This is a constraint that our implementation needs to take into account and a synchronization mechanism as will be described in our modeled application later in this section $\leftarrow$ {\bfseries do we? make sure it is not overemphasized here.}. 


\subsection{Await Construct}
The ``await" statement of ABS offers a high level mechanism that controls execution within an actor based on its internal state or the availability of the result of an asynchronous call via futures. A statement like "await future?" differs from "future.get" as it does not block the entire execution of the actor, but instead block the current message from which the ``await" statement was called and allows the actor to continue with executing other messages that are available in its queue. Similarly, for example "await this.boolVar" will suspend the current message executing this statement until the field boolVar is set to true (while another method is being executed). In both uses of the "await" construct the suspended message will be made available once the future is completed or the boolean condition evaluates to true. 
Even though a very simple concept, such a construct can simplify the logic of the program significantly. The effectiveness of this mechanism will be illustrated within the example in Section \ref{ag}. 
Furthermore, we will see some of the challenges encountered when implementing this behavior in Sections \ref{comp} and \ref{run}.        

- the main concepts: async calls, await on boolean and futures, each object has its own queue.
- example for coroutines (Paul Klint paper at SEN)

\subsection{Proof of concept}
\label{ag}
Here we illustrate the use of ABS in implementing Agent-based modeling languages.
Agent-based modeling has been shown to be a powerful means to express organizational abstractions of autonomous behavior, including auctioning systems \cite{agent_auction,bas16}.
However, it is still a major challenge to generate  \emph{production} code from  high-level agent-based modeling concepts, e.g., the deliberation cycle which integrates  goal-oriented computation with an event-based communication approach. 
To lower the barrier for adoption by industry, Dastani and Testerink \cite{bas16} propose a Java methodology which guides the development of agent-based models. 
This includes a corresponding library of object-oriented design patterns for modeling agent-based concepts, called OO2APL. 

OO2APL  includes a complex middleware for management of the deliberation cycle and the event-based communication between agents. 
Furthermore, this middleware is tightly coupled with the high-level design patterns for the deliberation cycle and  the event-based communication mechanism.
In contrast,  Listing \ref{list:Agent} shows that modeling agents directly by actors  allows to abstract in a concise manner from the underlying implementation of the deliberation cycle  and the event-based communication mechanism.
It provides  a high-level design pattern in ABS capturing the code structure for modeling agents with a clear separation of message plans and goal rules. 
The first three lines introduce the generic data types for goals, beliefs and messages.
In ABS, one can define the goals, beliefs and messages as abstract data types.
This makes it easy to define the plans for  handling incoming messages and the rules for processing the goals by means of pattern matching against these model-specific data types (lines 14 and 21, respectively, of Listing \ref{list:Agent}).
The general interface of an agent simply consists of a single method for receiving  messages. An  implementation of this interface consists of a set of beliefs and a set of goals which are initialized upon creation by means of a statement
\lstinline|Agent a1= new A1(B,G)|.
This statement  assigns to the variable a1 a dynamically generated  identity of the newly created agent and initializes its beliefs and goals (by  the actual parameters \lstinline|B| and \lstinline|G|).
Finally,  the \lstinline|run()| method (line 27 of  Listing \ref{list:Agent}) ensures proactive processing of the goal rules and allows for
interleaved processing of the messages by means of cooperative scheduling as invoked by the \lstinline|suspend| statement.
Thanks to the flexibility of ABS, one can easily adopt variations of the above design pattern.
For example, placing the \lstinline|suspend| statement inside the \lstinline|for| loop will allow interleaving individual goal rules with message plans.
Furthermore, application-specific scheduling policies \cite{rabs,cog}  may be applied if desired, for example, to give some goals or messages higher priorities.



\begin{lstlisting}[caption= Generic Agent Model, label=list:Agent]
data Goal = Goal;
data Belief = Belief;
data Message = Message;

interface Agent {
	Unit message(Message m);
}

class A1(Set<Belief> init_beliefs, Set<Goal> init_goals)  implements Agent {
	Set<Belief> beliefs = init_beliefs;
	Set<Goal> goals = init_goals;
	
	Unit message(Message m) {
		case m { 
			Message =>  { }
			_ => { }
		}
	}
	
	Unit goal_rule(Goal g) {
		case g {
			Goal => { }
			_ => { }
		}
	}
	
	Unit run() {
		 while(this.goals != EmptySet) {
  		    for (g in this.goals) {
		        this.goal_rule(g);
		    }
		  suspend;
		}
	}

}

\end{lstlisting}

%// example of a Main configuration
%{
%    Agent a1 = new A1(set[], set[Goal]);
%}





\begin{table}
	\caption{Characteristics of agents in an auctioning system}\label{tab:auc}
\begin{tabular}{|l|c|c|}
	\hline
	& AuctioneerAgent & BiddingAgent \\
	\hline
Goals & Item1, Item2 & Item1 \\
Beliefs & costs, timing constraints & budget, timing constraints, risk factor \\	
Received messages (plans) & Bid(item, value) & Announce (item) \\
 & & Sold (item) \\
Goal Rules & start auction for the goal & \\
\hline
\end{tabular}
\end{table}



Listing \ref{list:agent} shows (selected parts of) a concrete model of an agent  in an auctioning system.
This implementation corresponds to the characteristics described in Table \ref{tab:auc} for auctioning systems.
Auctioneer and bidding agents have the goals of selling and buying items, respectively, which are modeled using the type \lstinline|Item|. 
Furthermore in this table, we name a few possible parameters that may constitute the belief base of each agent and which may affect its behavior.
For example, the value of a bid brought up by an agent could be defined to be proportional to its budget and risk factor, whereas outside some timing constraints, the agent is not interested in bidding any more. 
Concretely, the above constitute an agent's {\em plan} in responding to the \lstinline|Announce| message.
In Listing \ref{list:agent}, for simplicity of the presentation, we provide as the initial beliefs, only two rational numbers (written as \lstinline|Rat|), the risk factor which is between 0 and 1, and the budget.
The message plan for handling \lstinline|Announce| is to calculate the bid value and respond to the auctioneer agent (references by the \lstinline|caller| argument).
We explicitly add here the \lstinline|caller| parameter of type Agent to allow replying to messages. 


\begin{lstlisting}[caption=Agents in an auctioning system, label=list:agent]
data Message = 
Announce(Agent announceCaller, Item  toSell) | 
Bid(Agent bidCaller, Item  toBuy, Price value) |
Sold(Agent soldCaller, Item soldItem);

class BiddingAgent(Item goal, Rat risk, Rat budget) implements Agent {
	Unit message(Message m) {
		case m {
			Announce(caller, offer) =>  {
			  if (offer == goal) {
			    Rat value = budget * risk;
			    await caller ! Bid(this, offer, value);
			  } 
			}
		}
	}
}
\end{lstlisting}

One challenge in modeling the auctioneer agent is how to make sure all bids from all interested agents have arrived and have been accounted for before starting the process of selecting the winning bid. 
A typical solution is to count the number of arriving bids and compare to the number of existing bidding agents. 
In addition to the extra bookkeeping for counting, this requires also the uninterested agents to send a response. 
In our ABS model, however, we solve this by means of a cooperation between the bidding and auctioneer agents.
When the auctioneer agent sends out \lstinline|Announce| messages as part of its goal rule, it can easily suspend the goal rule until the bidding agents have completed the processing the \lstinline|Announce| messages, either by sending a bid or after simply having decided that \lstinline|offer| is not the same as the agent's \lstinline|goal|.
But in order to select the winner, it is not enough to {\em receive} the bids; additionally, the bids need to have been processed.
In fact, the \lstinline|await| statement inside the bidding agent on sending a \lstinline|Bid| message makes sure that the current bid has been accounted for by the auctioneer before the current method in the bidding agent completes. 
Note additionally that since the execution of the goal rule inside the auctioneer agent is {\em suspended} and not {\em blocked}, the bid message may and will be processed before the goal rule is again enabled, after which the winner of the auction can be determined.
