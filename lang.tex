

\section{ABS Language Concepts}
\label{lang}
Our reference modeling language for analyzing cooperative scheduling is ABS\cite{abs}, an actor-based modeling language whose semantics offer high-level synchronization mechanisms for parallel and even distributed applications. This is a very powerful modeling language with extensive support for concurrent programming\cite{cog}, resource analysis\cite{saco}, deadlock analysis\cite{dead} and remote communication \cite{dis,cloud}. Our focus in this paper are the semantics of the language that offer high-level constructs for modeling asynchronous communication between actors using messages and cooperative scheduling of these messages by an actor.  The second construct can have optional annotations that define custom schedulers in order to satisfy an actor's specific behavior. Asynchronous method calls can also be annotated with costs and deadlines which can be combined with cooperative scheduling policies to create a very powerful scheduler.

\subsection{Asynchronous Method Invocation}\label{amc}
In ABS all actors communicate with each other using asynchronous method invocation generated by a very simple construct "a!m()" which sends a message to another actor "a" to execute method "m". The semantics allow synchronous method calls that only change the internal state of an actor. ABS also has support for grouping Actors into Concurrent Object Groups (COG) that allow synchronous communication between actors of the same COG, but for the scope of our analysis and implementation simplicity we will assume that each actor is defined in its own group. Furthermore the semantics of ABS impose that each actor has a queue that stores all invocations coming from other actors as messages that are to be executed. Each actor executes the messages sequentially in its own context therefore all actors run in parallel.  An important observation to make here is that in modeling an application, ABS assumes there is no "message overtaking", that is the order of messages delivered from one particular actor to another is the same as the order in which they were generated. This is a significant constraint that our implementation needs to take into account and an important synchronization mechanism as will be described in our modeled application later in this section. The result of an asynchronous method invocation can be captured in an future which the caller actor can use to retrieve the result and use it, but also to block its current execution in order to synchronize with the callee actor. This is done through the "future.get" statement that a future supplies and has the same semantics that futures have to synchronize concurrent objects in other modeling and programming languages.  

\subsection{Await Construct}
The "await" statement of ABS offers a high level mechanism that controls execution within an actor based on its internal state or the state of other actors in the system. As explained in Section \ref{amc}, futures can be used to synchronize between actors. However, in combination with the "await" construct, futures can also be used to control and suspend message execution within an actor. A statement like "await future?" differs from "future.get" as it doesn't block the entire execution of the actor, but instead block the current message from which the "await" statement was called and allows the actor to continue with executing subsequent messages that are available in its queue. The same behavior of an actor can also be achieved by combining the "await" statement with a boolean condition that describes a particular state of the actor. For example "await isPrime(this.x)" will suspend the current message executing this statement until the field x of the actor is set to a prime number. In both uses of the "await" contruct the suspended message will be made available once the future is completed or the boolean condition evaluates to true. The effectiveness of this mechanismm will be illustrated in a real example in Section \ref{ag}. While this behavior is very trivial to model, we will see some of the challenges encountered when implementing this behavior in Sections \ref{comp} and \ref{run}.        

- the main concepts: async calls, await on boolean and futures, each object has its own queue.
- example for coroutines (Paul Klint paper at SEN)

\subsection{Proof of Concept: Actor-based implementation of Agent-based Modelling}
\label{ag}
-expressive generic agent model \\
-software engineering context \\
- support for functional data types, FLI, type-checking\\
-sequence of events that maximize agent throughput\\