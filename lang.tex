

\section{ABS Language Concepts}
\label{lang}
Our reference modeling language for analyzing cooperative scheduling is ABS \cite{abs}, an actor-based modeling language whose semantics offers high-level synchronization mechanisms for parallel and  distributed applications. This is a very powerful modeling language with extensive support for concurrent programming \cite{cog}, resource analysis \cite{saco}, deadlock analysis \cite{dead} and remote communication \cite{dis,cloud}. Our focus in this paper are  high-level constructs for modeling asynchronous communication between actors using messages and cooperative scheduling of these messages by an actor.
%Mahdi:
{\bfseries the following are not the `focus of this paper' as suggested in the previous sentence}
The second construct can have optional annotations that define custom schedulers in order to satisfy an actor's specific behavior. Asynchronous method calls can also be annotated with costs and deadlines which can be combined with cooperative scheduling policies to create a very powerful scheduler.

\subsection{Asynchronous Method Invocation}\label{amc}
In ABS all actors communicate with each other using asynchronous method invocation.
This is written as ``a!m()" which sends a message to another actor ``a" to execute method ``m". 
The semantics additionally allows for synchronous method calls that only change the internal state of an actor $\leftarrow$ {\bfseries what does this mean?}. 
%ABS also has support for grouping Actors into Concurrent Object Groups (COG) that allow synchronous communication between actors of the same COG, but for the scope of our analysis and implementation simplicity we will assume that each actor is defined in its own group.  <-- then I would drop it from here
Each ABS actor has a queue that stores all invocations coming from other actors as messages that are to be executed. 
Each actor executes the messages sequentially in its own context while all actors run in parallel.  
The result of an asynchronous method invocation can be captured in an future which the caller actor can use to retrieve the result, but also to block its current execution in order to synchronize with the callee actor. 
This is done through the ``future.get" statement that a future supplies. % and has the same semantics as futures in other modeling and programming languages.  
One may also send the future as parameter to a message, allowing other actors to use the results.

An important observation to make here is that in modeling an application, ABS assumes there is no ``message overtaking", that is the order of messages delivered from one particular actor to another is the same as the order in which they were generated. 
This is a constraint that our implementation needs to take into account and a synchronization mechanism as will be described in our modeled application later in this section $\leftarrow$ {\bfseries do we? make sure it is not overemphasized here.}. 


\subsection{Await Construct}
The ``await" statement of ABS offers a high level mechanism that controls execution within an actor based on its internal state or the availability of the result of an asynchronous call via futures. A statement like "await future?" differs from "future.get" as it does not block the entire execution of the actor, but instead block the current message from which the ``await" statement was called and allows the actor to continue with executing other messages that are available in its queue. Similarly, for example "await this.boolVar" will suspend the current message executing this statement until the field boolVar is set to true (while another method is being executed). In both uses of the "await" construct the suspended message will be made available once the future is completed or the boolean condition evaluates to true. 
Even though a very simple concept, such a construct can simplify the logic of the program significantly. The effectiveness of this mechanism will be illustrated within the example in Section \ref{ag}. 
Furthermore, we will see some of the challenges encountered when implementing this behavior in Sections \ref{comp} and \ref{run}.        

- the main concepts: async calls, await on boolean and futures, each object has its own queue.
- example for coroutines (Paul Klint paper at SEN)

\subsection{Proof of concept}
\label{ag}
Here we illustrate the use of ABS in implementing Agent-based modeling languages.
Agent-based modeling has been shown to be a powerful means to express organizational abstractions of autonomous behavior, including auctioning systems \cite{agent_auction,bas16}.
However, it is still a major challenge to generate  \emph{production} code from  high-level agent-based modeling concepts, e.g., the deliberation cycle which integrates  goal-oriented computation with an event-based communication approach. 
To lower the barrier for adoption by industry, Dastani and Testerink \cite{bas16} propose a Java methodology which guides the development of agent-based models. 
This includes a corresponding library of object-oriented design patterns for modeling agent-based concepts, called OO2APL. 

OO2APL  includes a complex middleware for management of the deliberation cycle and the event-based communication between agents. 
Furthermore, this middleware is tightly coupled with the high-level design patterns for the deliberation cycle and  the event-based communication mechanism.
In contrast,  Listing \ref{list:Agent} shows that modeling agents directly by actors  allows to abstract in a concise manner from the underlying implementation of the deliberation cycle  and the event-based communication mechanism.
It provides  a high-level design pattern in ABS capturing the code structure for modeling agents with a clear separation of message plans and goal rules. 
The first three lines introduce the generic data types for goals, beliefs and messages.
In ABS, one can define the goals, beliefs and messages as abstract data types.
This makes it easy to define the plans for  handling incoming messages and the rules for processing the goals by means of pattern matching against these model-specific data types (lines 14 and 21, respectively, of Listing \ref{list:Agent} ).
The general interface of an agent simply consists of a single method for receiving  messages. An  implementation of this interface consists of a set of beliefs and a set of goals which are initialized upon creation by means of a statement
\lstinline|Agent a1= new A1(B,G)|.
This statement  assigns to the variable a1 a dynamically generated  identity of the newly created agent and initializes its beliefs and goals (by  the actual parameters \lstinline|B| and \lstinline|G|).
Finally,  the \lstinline|run()| method (line 27 of  Listing \ref{list:Agent}) ensures proactive processing of the goal rules and allows for
interleaved processing of the messages by means of cooperative scheduling as invoked by the \lstinline|suspend| statement.
Thanks to the flexibility of ABS, one can easily adopt variations of the above design pattern.
For example, placing the \lstinline|suspend| statement inside the \lstinline|for| loop will allow interleaving individual goal rules with message plans.
Furthermore, application-specific scheduling policies \cite{rabs,cog}  may be applied if desired, for example, to give some goals or messages higher priorities.



\begin{lstlisting}[caption= Generic Agent Model, label=list:Agent]
data Goal = Goal;
data Belief = Belief;
data Message = Message;

interface Agent {
	Unit message(Message m);
}

class A1(Set<Belief> init_beliefs, Set<Goal> init_goals)  implements Agent {
	Set<Belief> beliefs = init_beliefs;
	Set<Goal> goals = init_goals;
	
	Unit message(Message m) {
		case m { 
			Message =>  { }
			_ => { }
		}
	}
	
	Unit goal_rule(Goal g) {
		case g {
			Goal => { }
			_ => { }
		}
	}
	
	Unit run() {
		 while(this.goals != EmptySet) {
  		    for (g in this.goals) {
		        this.goal_rule(g);
		    }
		  suspend;
		}
	}

}

\end{lstlisting}

%// example of a Main configuration
%{
%    Agent a1 = new A1(set[], set[Goal]);
%}





\begin{table}
\begin{tabular}{|l|c|c|}
	\hline
	& AuctioneerAgent & BiddingAgent \\
	\hline
Goals & Item1, Item2 & Item1 \\
Beliefs & costs, timing constraints & budget, timing constraints, risk factor \\	
Received messages (plans) & Bid(item, value) & Announce (item) \\
 & & Sold (item) \\
Goal Rules & start auction for the goal & \\
\hline
\end{tabular}
\end{table}



Listing \ref{list:agent} shows a concrete model of an agent  in an auctioning system.
Here, we define four types of messages sent and received by auctioning and bidding agents.  TODO: more explanation required, i.e., what is the initial goal?


\begin{lstlisting}[caption= Agent Model, label=list:agent]
data Message = 
Announce(Agent announceCaller, Item  toSell, Price price) | 
Bid(Agent bidCaller, Item  toBuy, Price bid) |
Sold(Agent soldCaller, Item soldItem) |
Result(Set<Agent> winners, List<Price> prices, List<Agent> unhappy);

class BiddingAgent(Set<Belief>  [] , Set<Goal > set[init_goal], Rat risk) implements Agent {
	Set<Belief>  beliefs = [];
	Set<Goal> goals = set[init_goal];
        Rat risk = risk;
	
	Unit message(Message m) {
		case m {
			Announce(caller, slot, price) =>  { ...   } 
		        Sold(caller, slot) => { ... }
		}
	}
}
\end{lstlisting}


