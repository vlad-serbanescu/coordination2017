

\section{ABS Language Concepts}
\label{lang}
Our reference modeling language for analyzing cooperative scheduling is ABS\cite{abs}, an actor-based modeling language whose semantics offer high-level synchronization mechanisms for parallel and even distributed applications. This is a very powerful modeling language with extensive support for concurrent programming\cite{cog}, resource analysis\cite{saco}, deadlock analysis\cite{dead} and remote communication \cite{dis,cloud}. Our focus in this paper are the semantics of the language that offer high-level constructs for modeling asynchronous communication between actors using messages and cooperative scheduling of these messages by an actor.  The second construct can have optional annotations that define custom schedulers in order to satisfy an actor's specific behavior. Asynchronous method calls can also be annotated with costs and deadlines which can be combined with cooperative scheduling policies to create a very powerful scheduler.

\subsection{Asynchronous Method Invocation}\label{amc}
In ABS all actors communicate with each other using asynchronous method invocation generated by a very simple construct "a!m()" which sends a message to another actor "a" to execute method "m". The semantics allow synchronous method calls that only change the internal state of an actor. ABS also has support for grouping Actors into Concurrent Object Groups (COG) that allow synchronous communication between actors of the same COG, but for the scope of our analysis and implementation simplicity we will assume that each actor is defined in its own group. Furthermore the semantics of ABS impose that each actor has a queue that stores all invocations coming from other actors as messages that are to be executed. Each actor executes the messages sequentially in its own context therefore all actors run in parallel.  An important observation to make here is that in modeling an application, ABS assumes there is no "message overtaking", that is the order of messages delivered from one particular actor to another is the same as the order in which they were generated. This is a significant constraint that our implementation needs to take into account and an important synchronization mechanism as will be described in our modeled application later in this section. The result of an asynchronous method invocation can be captured in an future which the caller actor can use to retrieve the result and use it, but also to block its current execution in order to synchronize with the callee actor. This is done through the "future.get" statement that a future supplies and has the same semantics that futures have to synchronize concurrent objects in other modeling and programming languages.  

\subsection{Await Construct}
The "await" statement of ABS offers a high level mechanism that controls execution within an actor based on its internal state or the state of other actors in the system. As explained in Section \ref{amc}, futures can be used to synchronize between actors. However, in combination with the "await" construct, futures can also be used to control and suspend message execution within an actor. A statement like "await future?" differs from "future.get" as it doesn't block the entire execution of the actor, but instead block the current message from which the "await" statement was called and allows the actor to continue with executing subsequent messages that are available in its queue. The same behavior of an actor can also be achieved by combining the "await" statement with a boolean condition that describes a particular state of the actor. For example "await isPrime(this.x)" will suspend the current message executing this statement until the field x of the actor is set to a prime number. In both uses of the "await" contruct the suspended message will be made available once the future is completed or the boolean condition evaluates to true. The effectiveness of this mechanismm will be illustrated in a real example in Section \ref{ag}. While this behavior is very trivial to model, we will see some of the challenges encountered when implementing this behavior in Sections \ref{comp} and \ref{run}.        

- the main concepts: async calls, await on boolean and futures, each object has its own queue.
- example for coroutines (Paul Klint paper at SEN)

\subsection{Proof of concept}
\label{ag}

Agent-based modeling has been shown to be a powerful means to express organizational abstractions, including auctioning systems \cite{agent_auction,bas16}.
However, it is still a major challenge to provide an efficient implementation of these high-level agent-based modeling concepts, e.g., the deliberation cycle which integrates a goal-oriented computation with an event-based communication approach. 
To lower the barrier for adoption by industry, Dastani and Testerink \cite{bas16} propose a Java methodology which guides the development of agent-based models. 
This includes a corresponding library of object-oriented design patterns for modeling agent-based concepts, called OO2APL. 

A major part of the complexity in OO2APL stems from the implementation of a middleware for management of the deliberation cycle of and the event-based communication between agents. 
Furthermore, this middleware is tightly coupled with the high-level design patterns for agents.
In contrast,  Listing \ref{list:Agent} shows that modeling agents directly by actors  allows to abstract in a concise manner from the underlying implementation of the deliberation cycle  and the event-based communication mechanism.



\begin{lstlisting}[caption= Generic Agent Model, label=list:Agent]
data Goal = Goal;
data Belief = Belief;
data Message = Message;

interface Agent {
	Unit message(Message m);
}

class A1(Set<Belief> init_beliefs, Set<Goal> init_goals)  implements Agent {
	Set<Belief> beliefs = init_beliefs;
	Set<Goal> goals = init_goals;
	
	Unit message(Message m) {
		case m { 
			Message =>  { }
			_ => { }
		}
	}
	
	Unit goal_rule(Goal g) {
		case g {
			Goal => { }
			_ => { }
		}
	}
	
	Unit run() {
		 while(this.goals != EmptySet) {
		  for (g in this.goals) {
		      this.goal_rule(g);
		  }
		  suspend;
		}
	}

}

\end{lstlisting}

%// example of a Main configuration
%{
%    Agent a1 = new A1(set[], set[Goal]);
%}


Listing \ref{list:agent} shows a concrete instantiation of an agent  in an auctioning system.

\begin{lstlisting}[caption= Agent Model, label=list:agent]
data Message = 
Announce(Agent announceCaller, Route toSell, Price price) | 
Bid(Agent bidCaller, Route toBuy, Price bid) |
Sold(Agent soldCaller, Route soldItem) |
Result(Set<Agent> winners, List<Price> prices, List<Agent> unhappy);

class BiddingAgent(Belief init_value, Goal init_goal, Rat risk) implements Agent {
	Belief belief = init_value;
	Set<Goal> goals = set[init_goal];
	
	Unit message(Message m) {
		case m {
			Announce(caller, slot, price) =>  { ...   } 
		    Sold(caller, slot) => { ... }
		}
	}
}
\end{lstlisting}


a generic agent model

generic mechanism for querying the belief base by pattern matching 

no need for explicit registry of agents, so get for free garbage collection

we have a natural match between ABS methods and plan execution of agents, which the cooperative scheduling provides additional flexibility tin the implementation of the deliberation cycle.


-expressive generic agent model \\
-software engineering context \\
- support for functional data types, FLI, type-checking\\
-sequence of events that maximize agent throughput\\


